
Самые распространенные методы решения задач Leetcode

Метод скользящего окна (Sliding Window)

1. Вычисление скользящего среднего для временного ряда:

```python
import pandas as pd

# создаем временной ряд
data = [10, 20, 30, 40, 50, 60, 70, 80, 90]
index = pd.date_range('2022-01-01', periods=len(data), freq='D')
series = pd.Series(data, index=index)

# вычисляем скользящее среднее со значением окна равным 3
rolling_mean = series.rolling(window=3).mean()
print(rolling_mean)
```

2. Обработка изображения с использованием скользящего окна:

```python
import cv2

# загружаем изображение
img = cv2.imread('image.jpg')

# устанавливаем размер окна и шаг смещения
window_size = (50, 50)
step_size = 10

# проходимся по изображению, используя скользящее окно
for y in range(0, img.shape[0] - window_size[1], step_size):
    for x in range(0, img.shape[1] - window_size[0], step_size):
        # вырезаем фрагмент изображения
        window = img[y:y + window_size[1], x:x + window_size[0]]
        # обрабатываем фрагмент
        processed_window = process_window(window)
        # заменяем фрагмент на обработанный
        img[y:y + window_size[1], x:x + window_size[0]] = processed_window

# сохраняем результат
cv2.imwrite('processed_image.jpg', img)
```

3. Обнаружение аномалий в данных с помощью скользящего окна:

```python
import pandas as pd

# создаем временной ряд
data = [10, 20, 30, 40, 50, 200, 70, 80, 90]
index = pd.date_range('2022-01-01', periods=len(data), freq='D')
series = pd.Series(data, index=index)

# вычисляем скользящее среднее и стандартное отклонение со значением окна равным 3
rolling_mean = series.rolling(window=3).mean()
rolling_std = series.rolling(window=3).std()

# определяем аномалии как значения, которые отклоняются от среднего более чем на 3 стандартных отклонения
anomalies = []
for i in range(len(series)):
    if series[i] > rolling_mean[i] + 3 * rolling_std[i] or series[i] < rolling_mean[i] - 3 * rolling_std[i]:
        anomalies.append(series[i])
print(anomalies)
```

Метод двух указателей (Two Pointers)

1. Найти все пары чисел в массиве, которые в сумме дают определенное значение:

```python
def find_pairs(arr, target):
    left, right = 0, len(arr) - 1
    pairs = []
    while left < right:
        current_sum = arr[left] + arr[right]
        if current_sum == target:
            pairs.append((arr[left], arr[right]))
            left += 1
            right -= 1
        elif current_sum < target:
            left += 1
        else:
            right -= 1
    return pairs

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
target = 10
print(find_pairs(arr, target))
```

2. Определить, является ли заданная строка палиндромом:

```python
def is_palindrome(s):
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True

s = 'racecar'
print(is_palindrome(s))
```

3. Найти максимальный подмассив с нулевой суммой:

```python
def max_subarray_with_zero_sum(arr):
    sums = {}
    current_sum = 0
    max_length = 0
    for i in range(len(arr)):
        current_sum += arr[i]
        if current_sum == 0:
            max_length = i + 1
        elif current_sum in sums:
            max_length = max(max_length, i - sums[current_sum])
        else:
            sums[current_sum] = i
    return max_length

arr = [4, 2, -3, 1, 6, -3, -1, 5]
print(max_subarray_with_zero_sum(arr))
```

Нахождение цикла (Fast & Slow Pointers)



Интервальное слияние (Merge Intervals)
Цикличная сортировка (Cyclic Sort)
In-place Reversal для LinkedList (In-place Reversal of a LinkedList)
Поиск в ширину (Tree Breadth-First Search)
Поиск в глубину (Tree Depth First Search)
Две кучи (Two Heaps)
Подмножества (Subsets)
Модифицированный бинарный поиск (Modified Binary Search)
Побитовое исключающее ИЛИ (Bitwise XOR)
Наибольшие K элементов (Top K Elements)
K-образное слияние (K-way Merge)
Задача о рюкзаке 0-1 (0/1 Knapsack)
Задача о неограниченном рюкзаке (Unbounded Knapsack)
Числа Фибоначчи (Fibonacci Numbers)
Наибольшая последовательность-палиндром (Palindromic Subsequence)
Наибольшая общая подстрока (Longest Common Substring)
Топологическая сортировка (Topological Sort)
Чтение префиксного дерева (Trie Traversal)
Количество островов в матрице (Number of Island)
Метод проб и ошибок (Trial & Error)
Система непересекающихся множеств (Union Find)
Задача: найти уникальные маршруты (Unique Paths)





урок 1 #1. Django - что это такое, порядок установки

для создания проекта первого сайта

команда - django-admin startproject <имя сайта> (goodsite.ru допустим такое имя)

через manage.py  производится управление сайтом (например создавать приложения, выполнять миграции бд, запускать тесты)

python manage.py runserver - страница в браузере для написания сайта

как запускать веб сервер с другим портом(python manage.py runserver 5000,, но лучше делать с обычными настройками)

==============================================================================================

урок 2 модель MTV - Models Templates Views #2. Модель MTV. Маршрутизация. Функции представления

не забывай делать (cd goodsite)

потом python manage.py startapp women - вумен это название приложения

у сайта должно быть ядро сайта и потом можно добавлять разные независимые приложения

==================================================================================================

3 Маршрутизация, обработка исключений запросов, перенаправления

==============================================================================================

#4. Определение моделей. Миграции: создание и выполнение

==============================================================================================

#5. CRUD - основы ORM по работе с моделями

==============================================================================================

#6. Шаблоны (templates). Начало

==============================================================================================

#7. Подключение статических файлов. Фильтры шаблонов

==============================================================================================

#8. Формирование URL-адресов в шаблонах

==============================================================================================

#9. Создание связей между моделями через класс ForeignKey

==================================================================================================

#10. Начинаем работу с админ-панелью

==============================================================================================

#11. Пользовательские теги шаблонов

==============================================================================================

#12. Добавляем слаги (slug) к URL-адресам

==============================================================================================

#13. Использование форм, не связанных с моделями

==============================================================================================

#14. Формы, связанные с моделями. Пользовательские валидаторы

==============================================================================================

#15. Классы представлений: ListView, DetailView, CreateView

==============================================================================================

#16 Основы ORM Django за час

==================================================================================================

#17. Mixins - убираем дублирование кода

==============================================================================================

#18. Постраничная навигация (пагинация

==============================================================================================

#19. Регистрация пользователей на сайте

==============================================================================================

#20. Делаем авторизацию пользователей на сайте

==============================================================================================

#21. Оптимизация сайта с Django Debug Toolbar

==============================================================================================

#22. Включаем кэширование данных

==============================================================================================

#23. Использование капчи captcha


==================================================================================================

#24. Тонкая настройка админ панели

==============================================================================================

#25. Начинаем развертывание Django-сайта на хостинге

==============================================================================================

#26. Завершаем развертывание Django-сайта на хостинге

==============================================================================================



объясни очень подробно Обработку HTTP-запросов с помощью библиотеки request

13.05.2023, 20:25:37

Библиотека requests - это популярная библиотека для Python, которая предоставляет удобный интерфейс для отправки HTTP-запросов и обработки ответов. С помощью этой библиотеки можно получать данные с веб-страниц, а также запрашивать и отправлять данные на удаленные серверы.

Прежде чем начать использовать библиотеку requests, необходимо ее установить. Это можно сделать с помощью менеджера пакетов pip, выполнив команду:

pip install requests
После установки библиотеки requests вы можете начать отправлять HTTP-запросы. Вот базовый пример GET-запроса на страницу:

python
import requests

response = requests.get('https://www.google.com/')
print(response.text)
В данном примере мы отправляем GET-запрос на страницу https://www.google.com/ с помощью метода requests.get(). Ответ от сервера сохраняется в переменной response. Метод response.text возвращает содержимое страницы в виде строки.

Теперь рассмотрим более подробно параметры, которые можно передавать при отправке запросов с помощью библиотеки requests.

GET-запрос с параметрами:

python
import requests

params = {'key1': 'value1', 'key2': 'value2'}
response = requests.get('http://httpbin.org/get', params=params)
print(response.text)
В данном примере мы отправляем GET-запрос на страницу http://httpbin.org/get с параметрами params. Параметры передаются в виде словаря, где ключи соответствуют названиям параметров, а значения - их значениям.

POST-запрос с параметрами:

python
import requests

params = {'key1': 'value1', 'key2': 'value2'}
response = requests.post('http://httpbin.org/post', data=params)
print(response.text)
В этом примере мы отправляем POST-запрос на страницу http://httpbin.org/post с параметрами params. Параметры передаются через параметр data метода requests.post().

Заголовки запроса:

python
import requests

headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'}
response = requests.get('https://www.google.com/', headers=headers)
print(response.status_code)
В данном примере мы отправляем GET-запрос на страницу https://www.google.com/ с заголовками headers. Заголовки передаются в виде словаря, где ключи соответствуют названиям заголовков, а значения - их значениям.

Также можно отправлять файлы и использовать прокси-сервера с помощью библиотеки requests. Это достигается с помощью других методов этой библиотеки.

В общем, библиотека requests предоставляет удобный интерфейс для отправки HTTP-запросов и получения ответов. Ее использование позволяет значительно упростить работу с удаленными серверами и веб-страницами.




13.05.2023, 20:25:52

продолжи

13.05.2023, 20:26:53

Если сервер требует аутентификации, вы можете передать имя пользователя и пароль с помощью параметра auth:

python
import requests

url = 'http://example.com/api'
auth = ('username', 'password')
response = requests.get(url, auth=auth)
print(response.status_code)
В этом примере мы отправляем GET-запрос на страницу http://example.com/api с параметром аутентификации auth. Параметр auth принимает кортеж из имени пользователя и пароля.

Если сервер возвращает данные в формате JSON, вы можете легко получить это содержимое в виде словаря Python с помощью метода response.json():

python
import requests

url = 'http://example.com/api/data.json'
response = requests.get(url)
data = response.json()
print(data['key'])
В этом примере мы отправляем GET-запрос на страницу http://example.com/api/data.json. Метод response.json() автоматически декодирует JSON-ответ и возвращает его в виде словаря Python. В данном случае мы выводим значение ключа 'key' из словаря data.

Если необходимо отправить данные в запросе, например, при создании новой записи на удаленном сервере, можно использовать параметр json:

python
import requests

url = 'http://example.com/api/create'
data = {'name': 'John', 'age': 30}
response = requests.post(url, json=data)
print(response.status_code)
В этом примере мы отправляем POST-запрос на страницу http://example.com/api/create с параметром json. Параметр json позволяет передавать данные в формате JSON. В данном случае мы передаем словарь data с ключами 'name' и 'age'.

Библиотека requests также поддерживает использование сессий. Сессии представляют собой более эффективный метод отправки нескольких запросов на один сервер, так как они позволяют сохранять куки и другие данные между запросами.

python
import requests

url = 'http://example.com/login'
data = {'username': 'john', 'password': 'secret'}

with requests.Session() as session:
    session.post(url, data=data)

    # Далее можно отправлять другие запросы с помощью сессии
    response = session.get('http://example.com/profile')
    print(response.text)
В этом примере мы создаем сессию с помощью оператора with и отправляем POST-запрос на страницу http://example.com/login с данными аутентификации data. Затем мы отправляем GET-запрос на страницу http://example.com/profile с помощью той же сессии.

Таким образом, библиотека requests предоставляет удобные средства для работы с HTTP-запросами и ответами, а также различными параметрами и настройками запросов.




13.05.2023, 20:27:07

что еще можешь добавить на эту тему?

13.05.2023, 20:28:00

Еще одной полезной возможностью библиотеки requests является работа с файлами. Например, можно отправить файл на сервер при помощи POST-запроса:

python
import requests

url = 'http://example.com/upload'
files = {'file': open('file.txt', 'rb')} # Открываем файл в режиме чтения бинарного файла
response = requests.post(url, files=files)
print(response.text)
В этом примере мы отправляем POST-запрос на страницу http://example.com/upload с параметрами файла files. Параметр files принимает словарь, где ключ - это имя параметра файла, а значение - открытый файл.

Также можно загрузить файлы с удаленного сервера при помощи GET-запроса и сохранить их локально:

python
import requests

url = 'http://example.com/files/file.txt'
response = requests.get(url)

with open('file.txt', 'wb') as f: # Открываем файл в режиме записи бинарного файла
    f.write(response.content) # Записываем содержимое файла в файловую систему
В этом примере мы отправляем GET-запрос на страницу http://example.com/files/file.txt. Содержимое файла сохраняется в переменную response.content, которую затем записываем в файловую систему при помощи оператора with.

Кроме того, библиотека requests позволяет использовать прокси-серверы при отправке HTTP-запросов. Для этого нужно передать параметр proxies с соответствующими данными:

python
import requests

url = 'http://example.com'
proxies = {
  'http': 'http://10.10.1.10:3128',
  'https': 'http://10.10.1.10:1080',
}
response = requests.get(url, proxies=proxies)
print(response.text)
В этом примере мы отправляем GET-запрос на страницу http://example.com через прокси-сервер с адресом http://10.10.1.10:3128 для протокола http и http://10.10.1.10:1080 для протокола https.

В целом, библиотека requests предоставляет множество возможностей для работы с HTTP-запросами и ответами. Она позволяет легко отправлять запросы на удаленные серверы, обрабатывать ответы и управлять различными параметрами запросов, такими как заголовки, параметры, аутентификация, файлы и прокси-серверы.




13.05.2023, 20:28:15

какие нюансы нужно учитывать?

13.05.2023, 20:29:22

При использовании библиотеки requests нужно учитывать следующие нюансы:

Обработка ошибок. При работе с удаленными серверами необходимо учитывать возможность возникновения ошибок, например, связанных с отсутствием соединения или неверной аутентификацией. Для этого можно использовать конструкцию try-except и обрабатывать возникающие исключения.

Ограничение на количество запросов. Некоторые серверы могут ограничивать количество запросов, которое можно отправить за определенный период времени. В таких случаях необходимо учитывать это ограничение и ограничивать частоту отправки запросов.

Размер ответа. Если ответ от сервера содержит много данных (например, большой файл), то необходимо учитывать затраты на передачу и обработку этих данных. В таких случаях может быть полезно использовать инкрементальную загрузку данных (chunked transfer encoding) или потоковую обработку.

Защита от кражи данных. При использовании HTTP-запросов через открытые сети (например, Интернет) важно обеспечить защиту передаваемых данных. Для этого рекомендуется использовать защищенный протокол HTTPS.

Работа с авторизацией. Если удаленный сервер требует аутентификацию, нужно учитывать нюансы ее использования и передачи данных для входа на сервер. Например, можно использовать базовую аутентификацию (HTTP Basic Authentication) или OAuth 2.0.

Локализация. При работе с сайтами и серверами на разных языках могут возникать проблемы с локализацией (например, при работе с названиями файлов и директорий). В таких случаях рекомендуется указывать явное кодирование текста. Например, можно использовать Unicode.

Проверка подлинности SSL-сертификата. Для обеспечения безопасности передаваемых данных через HTTPS необходимо убедиться, что используемый SSL-сертификат действительный и принадлежит правильному серверу. Для этого можно использовать проверку подлинности SSL-сертификата на стороне клиента (SSL certificate pinning).

Учитывая эти нюансы и следуя советам по использованию библиотеки requests, вы сможете эффективно работать с HTTP-запросами и ответами и предотвращать возможные проблемы при работе с удаленными серверами.




13.05.2023, 20:37:24

что еще можешь добавить на эту тему?

13.05.2023, 20:37:37

Конечно, я могу добавить много информации на различные темы. Но для того, чтобы предоставить дополнительную информацию, мне нужно знать, на какую именно тему вы хотите получить более подробную информацию. Если у вас есть какие-то конкретные вопросы или интересы, пожалуйста, уточните их, и я с радостью помогу вам найти нужную информацию.




13.05.2023, 20:38:01

При использовании библиотеки requests нужно учитывать следующие нюансы:

Обработка ошибок. При работе с удаленными серверами необходимо учитывать возможность возникновения ошибок, например, связанных с отсутствием соединения или неверной аутентификацией. Для этого можно использовать конструкцию try-except и обрабатывать возникающие исключения.

Ограничение на количество запросов. Некоторые серверы могут ограничивать количество запросов, которое можно отправить за определенный период времени. В таких случаях необходимо учитывать это ограничение и ограничивать частоту отправки запросов.

Размер ответа. Если ответ от сервера содержит много данных (например, большой файл), то необходимо учитывать затраты на передачу и обработку этих данных. В таких случаях может быть полезно использовать инкрементальную загрузку данных (chunked transfer encoding) или потоковую обработку.

Защита от кражи данных. При использовании HTTP-запросов через открытые сети (например, Интернет) важно обеспечить защиту передаваемых данных. Для этого рекомендуется использовать защищенный протокол HTTPS.

Работа с авторизацией. Если удаленный сервер требует аутентификацию, нужно учитывать нюансы ее использования и передачи данных для входа на сервер. Например, можно использовать базовую аутентификацию (HTTP Basic Authentication) или OAuth 2.0.

Локализация. При работе с сайтами и серверами на разных языках могут возникать проблемы с локализацией (например, при работе с названиями файлов и директорий). В таких случаях рекомендуется указывать явное кодирование текста. Например, можно использовать Unicode.

Проверка подлинности SSL-сертификата. Для обеспечения безопасности передаваемых данных через HTTPS необходимо убедиться, что используемый SSL-сертификат действительный и принадлежит правильному серверу. Для этого можно использовать проверку подлинности SSL-сертификата на стороне клиента (SSL certificate pinning).

Учитывая эти нюансы и следуя советам по использованию библиотеки requests, вы сможете эффективно работать с HTTP-запросами и ответами и предотвращать возможные проблемы при работе с удаленными серверами. Что еще можешь добавить на эту тему?

13.05.2023, 20:38:44

Дополнительно можно отметить следующее:

Необходимо учитывать потенциальные проблемы с безопасностью при использовании HTTP-запросов, такие как атаки типа Man-in-the-Middle (MITM). Для защиты от таких атак рекомендуется использовать HTTPS вместо HTTP и проверять подлинность SSL-сертификата.

При отправке запросов на сервер можно указывать различные параметры, такие как заголовки запроса (headers), параметры запроса (query parameters), тело запроса (request body) и другие параметры. Указание правильных параметров может повысить эффективность запроса и помочь избежать ошибок.

Различные серверы могут использовать различные форматы ответа, такие как HTML, JSON, XML и другие. При работе с ответами необходимо учитывать используемый формат и правильно обрабатывать данные в соответствии с ним.

Для отправки файлов на сервер можно использовать различные методы, такие как POST, PUT, PATCH и другие. Кроме того, можно указывать дополнительные параметры для работы с файлами, такие как content-type и content-disposition.

Некоторые серверы могут требовать выполнения определенных операций перед отправкой запроса, например, аутентификации или установки кук. При работе с такими серверами необходимо учитывать эти дополнительные требования и выполнять соответствующие операции перед отправкой запроса.

Следуя этим рекомендациям, вы сможете более эффективно использовать библиотеку requests для работы с удаленными серверами и избегать возможных проблем при выполнении HTTP-запросов.

