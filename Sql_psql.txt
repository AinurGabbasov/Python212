
Последовательность выполнения операций на сервере:

MySQL: FROM => WHERE = SELECT = GROUP BY = HAVING = ORDER BY = LIMIT.

PostgreSQL: FROM => WHERE = GROUP BY = HAVING = SELECT = DISTINCT = ORDER BY = LIMIT.

===================================================================================
Создание таблицы

Ключевые слова: SQL не является регистрозависимым языком (CREATE и create - одно и тоже ключевое слово).
Ключевые слова SQL и типы данных рекомендуется  записывать прописными (большими) буквами.
Имена таблиц и полей - строчными (маленькими) буквами.
SQL-запрос можно писать на нескольких строках.
В конце SQL-запроса ставится точка с запятой (хотя если Вы пишете один запрос, это необязательно).



==============================================================================
Вставка записи в таблицу
==============================================================================
Выборка всех данных из таблицы

SELECT * FROM book;
==============================================================================
Выборка отдельных столбцов

SELECT title, amount FROM book;
==============================================================================
Выборка новых столбцов и присвоение им новых имен

SELECT title AS Название, amount
FROM book;

+-----------------------+--------+
| Название              | amount |
+-----------------------+--------+
| Мастер и Маргарита    | 3      |
| Белая гвардия         | 5      |
| Идиот                 | 10     |
| Братья Карамазовы     | 2      |
| Стихотворения и поэмы | 15     |
+-----------------------+--------+
==============================================================================
Выборка данных с созданием вычисляемого столбца

SELECT title, author, price, amount, price * amount AS total
FROM book;




==============================================================================
Выборка данных, вычисляемые столбцы, математические функции
==============================================================================
Выборка данных, вычисляемые столбцы, логические функции

IF(логическое_выражение, выражение_1, выражение_2)
Функция вычисляет логическое_выражение, если оно истина – в поле заносится значение выражения_1, в противном случае –  значение выражения_2. Все три параметра IF() являются обязательными.

Допускается использование вложенных функций, вместо выражения_1 или выражения_2 может стоять новая функция IF.

SELECT author, title,
CASE
    WHEN author = 'Булгаков М.А.' THEN ROUND(price * 1.1 , 2)
    WHEN author = 'Есенин С.А.' THEN ROUND(price * 1.05, 2)
    ELSE price
END AS new_price
FROM book;
==============================================================================

Выборка данных по условию

SELECT title, price
FROM book
WHERE price < 600;

==============================================================================

Выборка данных, логические операции

Вывести название, автора и цену тех книг, которые написал Булгаков, ценой больше 600 рублей

SELECT title, author, price
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';

==============================================================================
Выборка данных, операторы BETWEEN, IN

 Логическое выражение после ключевого слова WHERE может включать операторы  BETWEEN и IN. Приоритет  у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем NOT, AND, OR.

Оператор BETWEEN позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

Пример

Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.

Запрос:

SELECT title, amount
FROM book
WHERE amount BETWEEN 5 AND 14;

==============================================================================

Выборка данных с сортировкой

При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для этого используются ключевые слова ORDER BY, после которых задаются имена столбцов. При этом строки сортируются по первому столбцу, если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. По умолчанию ORDER BY выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово ASC (по возрастанию) или DESC (по убыванию).

Столбцы после ключевого слова ORDER BY можно задавать:

названием столбца;
номером столбца;
именем столбца (указанным после AS).
Пример

Вывести название, автора и цены книг. Информацию  отсортировать по названиям книг в алфавитном порядке.

Запрос:

SELECT title, author, price
FROM book
ORDER BY title;

==============================================================================

Выборка данных, оператор LIKE
Оператор LIKE используется для сравнения строк. В отличие от операторов отношения равно (=) и не равно (<>),
LIKE позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном.
Шаблон может включать обычные символы и символы-шаблоны. При сравнении с шаблоном, его обычные символы
должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с
произвольными элементами символьной строки.

SELECT title
FROM book
WHERE title LIKE 'Б%';

==============================================================================

Выбор уникальных элементов столбца

Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово
 DISTINCT, которое размещается сразу после SELECT.

Пример

Выбрать различных авторов, книги которых хранятся в таблице book.

Запрос:

SELECT DISTINCT author
FROM book;
Результат:

+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+

==============================================================================

Выборка данных, групповые функции SUM и COUNT

При группировке над элементами столбца, входящими в группу
можно выполнить различные действия, например, просуммировать
их или найти количество элементов в группе.



Посчитать, количество различных книг и количество экземпляров книг каждого автора , хранящихся на складе.
 Столбцы назвать Автор, Различных_книг и Количество_экземпляров соответственно.

SELECT author AS Автор, COUNT(amount) AS Различных_книг, SUM(amount) AS Количество_экземпляров
FROM book
GROUP BY author
==============================================================================


Выборка данных, групповые функции MIN, MAX и AVG

К групповым функциям SQL относятся: MIN(), MAX() и AVG(), которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

Пример

Вывести минимальную цену книги каждого автора

Запрос:

SELECT author, MIN(price) AS min_price
FROM book
GROUP BY author;
Результат:

+------------------+-----------+
| author           | min_price |
+------------------+-----------+
| Булгаков М.А.    | 540.50    |
| Достоевский Ф.М. | 460.00    |
| Есенин С.А.      | 650.00    |
+------------------+-----------+
==============================================================================

Выборка данных c вычислением, групповые функции

В качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.

Пример

Вывести суммарную стоимость книг каждого автора.

Запрос:

SELECT author, SUM(price * amount) AS Стоимость
FROM book
GROUP BY author;
Результат:

+------------------+-----------+
| author           | Стоимость |
+------------------+-----------+
| Булгаков М.А.    | 4715.47   |
| Достоевский Ф.М. | 11802.03  |
| Есенин С.А.      | 9750.00   |
+------------------+-----------+
==============================================================================

Вычисления по таблице целиком

Групповые функции позволяют вычислять итоговые значения по всей таблице. Например, можно посчитать общее количество книг на складе, вычислить суммарную стоимость и пр. Для этого после ключевого слова SELECT указывается групповая функция для выражения или имени столбца, а ключевые слова GROUP BY опускаются.

Пример

Посчитать количество экземпляров книг на складе.

Запрос:

SELECT SUM(amount) AS Количество
FROM book;
Результат:

+------------+
| Количество |
+------------+
| 46         |
+------------+

==============================================================================

Выборка данных по условию, групповые функции

В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после WHERE. В запросах с групповыми функциями вместо WHERE используется ключевое слово HAVING , которое размещается после оператора GROUP BY.

Пример

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000.

Запрос:

SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000;
Результат:

+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
| Есенин С.А.      | 650.00           | 650.00            |
+------------------+------------------+-------------------+
==============================================================================

Вложенный запрос, возвращающий одно значение

Вложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей WHERE как обычное значение совместно с операциями =, <>, >=, <=, >, <.

Пример

Вывести информацию о самых дешевых книгах, хранящихся на складе.

Для реализации этого запроса нам необходимо получить минимальную цену из столбца price таблицы book, а затем вывести информацию о тех книгах, цена которых  равна минимальной. Первая часть  – поиск  минимума – реализуется вложенным запросом.

Запрос:

SELECT title, author, price, amount
FROM book
WHERE price = (
         SELECT MIN(price)
         FROM book
      );
Результат:

+-------+------------------+--------+--------+
| title | author           | price  | amount |
+-------+------------------+--------+--------+
| Идиот | Достоевский Ф.М. | 460.00 | 10     |
+-------+------------------+--------+--------+
Вложенный запрос определяет минимальную цену книг во всей таблице (это 460.00), а затем в основном запросе для каждой записи проверяется, равна ли цена минимальному значению, если равна, информация о книге включается в результирующую таблицу запроса.


==============================================================================

Использование вложенного запроса в выражении

Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему можно что-то прибавить, вычесть и пр.

Пример

Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3. То есть нужно вывести и те книги, количество экземпляров которых меньше среднего на 3, или больше среднего на 3.

Запрос:

SELECT title, author, amount
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;
Результат:

+-----------------------+------------------+--------+
| title                 | author           | amount |
+-----------------------+------------------+--------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      |
| Братья Карамазовы     | Достоевский Ф.М. | 3      |
| Стихотворения и поэмы | Есенин С.А.      | 15     |
+-----------------------+------------------+--------+

Задание
Вывести информацию (автора, название и цену) о тех книгах,
 цены которых превышают минимальную цену книги на складе не
 более чем на 150 рублей в отсортированном по возрастанию цены виде.


SELECT author, title, price
FROM book
WHERE price-(SELECT MIN(price) FROM book)<=150
ORDER BY price;

==============================================================================

Вложенный запрос, оператор IN

Вложенный запрос может возвращать несколько значений одного столбца.  Тогда его можно использовать в разделе WHERE совместно с оператором IN.

WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)
Оператор IN определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе. При этом логическое выражение после WHERE получает значение истина. Оператор NOT IN выполняет обратное действие – выражение истинно, если значение столбца не содержится во вложенном запросе.

Пример

Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не менее 12.

Запрос:

SELECT title, author, amount, price
FROM book
WHERE author IN (
        SELECT author
        FROM book
        GROUP BY author
        HAVING SUM(amount) >= 12
      );
Результат:

+-----------------------+------------------+--------+--------+
| title                 | author           | amount | price  |
+-----------------------+------------------+--------+--------+
| Идиот                 | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 799.01 |
| Игрок                 | Достоевский Ф.М. | 10     | 480.50 |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 650.00 |
+-----------------------+------------------+--------+--------+

==============================================================================

Вложенный запрос, операторы ANY и ALL

==============================================================================

Вложенный запрос после SELECT

Вложенный запрос может располагаться после ключевого слова SELECT.
 В этом случае результат выполнения запроса выводится в
 отдельном столбце результирующей таблицы.
 При этом результатом запроса может быть только одно значение,
  тогда оно будет повторяться во всех строках.
  Также вложенный запрос может использоваться в выражениях.

Пример

Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг.

Запрос:

SELECT title, author, amount,
    (
     SELECT AVG(amount)
     FROM book
    ) AS Среднее_количество
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;

==============================================================================
Создание пустой таблицы CREATE

Добавление записей в таблицу INSERT

добавить записи из другой таблицы;
добавить записи из другой таблицы, используя вложенный запрос;
изменить значения в одном столбце;
изменить значения в нескольких столбцах;
изменить данные, используя несколько таблиц;
удалить записи из таблицы;
создать таблицу на основе данных других таблиц.

==============================================================================

Задание
Вывести из таблицы trip информацию о командировках тех сотрудников, фамилия которых заканчивается на букву «а», в отсортированном по убыванию даты последнего дня командировки виде. В результат включить столбцы name, city, per_diem, date_first, date_last.

Результат
+---------------+-----------------+----------+------------+------------+
| name          | city            | per_diem | date_first | date_last  |
+---------------+-----------------+----------+------------+------------+
| Абрамова К.А. | Владивосток     | 450.00   | 2020-07-02 | 2020-07-13 |
| Федорова А.Ю. | Томск           | 450.00   | 2020-06-20 | 2020-06-26 |
| Абрамова К.А. | Санкт-Петербург | 700.00   | 2020-05-28 | 2020-06-04 |
| Федорова А.Ю. | Новосибирск     | 450.00   | 2020-05-25 | 2020-06-04 |
| Абрамова К.А. | Москва          | 700.00   | 2020-04-06 | 2020-04-14 |
| Абрамова К.А. | Москва          | 700.00   | 2020-02-23 | 2020-03-01 |
| Абрамова К.А. | Владивосток     | 450.00   | 2020-01-14 | 2020-01-27 |
+---------------+-----------------+----------+------------+------------+

SELECT name, city, per_diem, date_first, date_last
FROM trip
WHERE name LIKE '%а %'
ORDER BY date_last desc;

==============================================================================

Задание
Вывести в алфавитном порядке фамилии и инициалы тех сотрудников, которые были в командировке в Москве.

Результат
+---------------+
| name          |
+---------------+
| Абрамова К.А. |
| Баранов П.Е.  |
| Колесов С.П.  |
| Лебедев Т.К.  |
| Семенов И.В.  |
+---------------+

SELECT DISTINCT name
FROM trip
WHERE city = "Москва"
ORDER BY name;

==============================================================================

Задание
Для каждого города посчитать, сколько раз сотрудники в нем были.  Информацию вывести в отсортированном в алфавитном порядке по названию городов. Вычисляемый столбец назвать Количество.

Результат
+-----------------+------------+
| city            | Количество |
+-----------------+------------+
| Владивосток     | 3          |
| Воронеж         | 1          |
| Москва          | 7          |
| Новосибирск     | 4          |
| Санкт-Петербург | 3          |
| Томск           | 2          |
+-----------------+------------+

SELECT city, count(city)'Количество'
FROM trip
GROUP BY city
ORDER BY city;

==============================================================================

Оператор LIMIT

Для ограничения вывода записей в SQL используется оператор LIMIT ,
после которого указывается количество строк.
  Результирующая таблица будет иметь количество строк не более указанного после LIMIT.
  LIMIT размещается после раздела ORDER BY.

 Пример

Вывести информацию о первой  командировке из таблицы trip. "Первой" считать командировку с самой ранней датой начала.

Запрос:

SELECT *
FROM trip
ORDER BY  date_first
LIMIT 1;
Результат:

+---------+--------------+--------+----------+------------+------------+
| trip_id | name         | city   | per_diem | date_first | date_last  |
+---------+--------------+--------+----------+------------+------------+
| 1       | Баранов П.Е. | Москва | 700.00   | 2020-01-12 | 2020-01-17 |
+---------+--------------+--------+----------+------------+------------+

==============================================================================

Задание
Вывести два города, в которых чаще всего были в командировках сотрудники.
Вычисляемый столбец назвать Количество.

SELECT city, count(city)'Количество'
FROM trip
GROUP BY city
ORDER BY Количество DESC

==============================================================================

Разница дней в PostgreSQL:

DATE_PART('day', date_last::timestamp - date_first::timestamp) + 1 AS Длительность

Задание
Вывести информацию о командировках во все города кроме Москвы и Санкт-Петербурга
(фамилии и инициалы сотрудников, город ,  длительность командировки в днях,
при этом первый и последний день относится к периоду командировки).
 Последний столбец назвать Длительность. Информацию вывести в упорядоченном
 по убыванию длительности поездки,
 а потом по убыванию названий городов (в обратном алфавитном порядке).


SELECT name, city,
(DATEDIFF(date_last, date_first)+1) AS 'Длительность'
FROM trip
WHERE city NOT IN ('Москва','Санкт-Петербург')
ORDER BY Длительность DESC
==============================================================================


Задание
Вывести информацию о командировках сотрудника(ов),
которые были самыми короткими по времени.
В результат включить столбцы name, city, date_first, date_last.
==============================================================================
Задание
Вывести информацию о командировках, начало и конец которых относятся к одному месяцу (год может быть любой). В результат включить столбцы name, city, date_first, date_last. Строки отсортировать сначала  в алфавитном порядке по названию города, а затем по фамилии сотрудника .

Немного теории

Для того, чтобы выделить номер месяца из даты используется функция MONTH(дата).

Например, MONTH('2020-04-12') = 4.

Если определяется месяц для  значений столбца date_first, то используется запись MONTH(date_first)

SELECT name, city, date_first, date_last
FROM trip
WHERE month(date_first) = month(date_last)
ORDER BY city, name
==============================================================================

Задание
Вывести название месяца и количество командировок для каждого месяца.
Считаем, что командировка относится к некоторому месяцу, если она началась в этом месяце.
Информацию вывести сначала в отсортированном по убыванию количества,
а потом в алфавитном порядке по названию месяца виде. Название столбцов – Месяц и Количество.

Немного теории

Для того, чтобы выделить название месяца из даты используется функция MONTHNAME(дата),
которая возвращает название месяца на английском языке для указанной даты.
Например, MONTHNAME('2020-04-12')='April'.
Если группировка осуществляется по вычисляемому столбцу
(в данном случае «вычисляется» название месяца), то после GROUP BY
можно указать как вычисляемое выражение, так и имя столбца, заданное
с помощью AS. Важно отметить, что последний вариант (указать имя столбца)
 нарушает стандарт по порядку выполнения запросов, но иногда может встречаться на реальных платформах.
Результат
+----------+------------+
| Месяц    | Количество |
+----------+------------+
| February | 4          |
| January  | 4          |
| June     | 3          |
| May      | 3          |
| April    | 2          |
| July     | 2          |
| March    | 2          |
+----------+------------+

SELECT MONTHNAME(date_first) AS Месяц, COUNT(MONTHNAME(date_first)) AS Количество
FROM trip
GROUP BY MONTHNAME(date_first)
ORDER BY COUNT(MONTHNAME(date_first)) DESC, MONTHNAME(date_first) ASC


==============================================================================

SELECT name, city, date_first, (
    (date_last::date - trip.date_first::date + 1) * per_diem
    ) as Сумма, to_char(date_first, 'Month')
FROM trip
WHERE EXTRACT(MONTH from date_first) in (2, 3)
ORDER BY name, Сумма DESC
для postgre

Задание
Вывести сумму суточных (произведение количества дней командировки и размера суточных)
для командировок, первый день которых пришелся на февраль или март 2020 года.
 Значение суточных для каждой командировки занесено в столбец per_diem.
 Вывести фамилию и инициалы сотрудника, город, первый день командировки и сумму суточных.
 Последний столбец назвать Сумма. Информацию отсортировать сначала  в
 алфавитном порядке по фамилиям сотрудников, а затем по убыванию суммы суточных.

Пояснение
1. В SQL есть функции, которые позволяют выделить часть даты:
день(DAY()), месяц (MONTH()), год(YEAR()) . Например:

DAY('2020-02-01') = 1
MONTH('2020-02-01') = 2
YEAR('2020-02-01') = 2020

SELECT name, city, date_first, (DATEDIFF(date_last, date_first)+1)*per_diem AS Сумма
FROM trip
WHERE MONTHNAME(date_first) IN('February','March')
ORDER BY name, Сумма DESC;





==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

==============================================================================

